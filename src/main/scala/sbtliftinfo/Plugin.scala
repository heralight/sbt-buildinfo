package sbtliftinfo

import sbt._

object Plugin extends sbt.Plugin {
  import Keys._

  lazy val liftInfo        = TaskKey[Seq[File]]("liftinfo")
  lazy val liftInfoObject  = SettingKey[String]("liftinfo-object")
  lazy val liftInfoPackage = SettingKey[String]("liftinfo-package")
  lazy val liftInfoKeys    = SettingKey[Seq[LiftInfoKey.Entry[_]]]("liftinfo-keys")
  lazy val liftInfoBuildNumber = TaskKey[Int]("liftinfo-buildnumber")
  lazy val liftInfoDirDestination = SettingKey[File]("liftinfo-dirprops", "liftinfo Directory")

  override def globalSettings = Seq(
    liftInfoObject := "LiftInfo"// ,
//    liftInfoDirDestination in Global <<=  (sourceDirectory in Global) apply  { (dir) =>
//    dir / "main" / "resources"
//    }
  )



  object LiftInfoKey {
    implicit def setting[A](key: SettingKey[A]): Entry[A] = Setting(key)
    implicit def task[A](key: TaskKey[A]): Entry[A] = Task(key)
    implicit def constant[A: Manifest](tuple: (String, A)): Entry[A] = Constant(tuple)
    
    def apply[A](key: SettingKey[A]): Entry[A] = Setting(key)
    def apply[A](key: TaskKey[A]): Entry[A] = Task(key)
    def apply[A: Manifest](tuple: (String, A)): Entry[A] = Constant(tuple)
    def map[A, B: Manifest](from: Entry[A])(fun: ((String, A)) => (String, B)): Entry[B] =
      LiftInfoKey.Mapped(from, fun)
    def action[A: Manifest](name: String)(fun: => A): Entry[A] = Action(name, () => fun)

    private[Plugin] final case class Setting[A](scoped: SettingKey[A]) extends Entry[A] {
      def manifest = scoped.key.manifest
    }
    private[Plugin] final case class Task[A](scoped: TaskKey[A]) extends Entry[A] {
      def manifest = scoped.key.manifest.typeArguments.head.asInstanceOf[Manifest[A]]
    }

    private[Plugin] final case class Constant[A](tuple: (String, A))(implicit val manifest: Manifest[A])
    extends Entry[A]

    private[Plugin] final case class Mapped[A, B](from: Entry[A], fun: ((String, A)) => (String, B))
                                                 (implicit val manifest: Manifest[B])
    extends Entry[B]

    private[Plugin] final case class Action[A](name: String, fun: () => A)(implicit val manifest: Manifest[A])
    extends Entry[A]

    sealed trait Entry[A] {
      private[Plugin] def manifest: Manifest[A]
    }
  }

  type LiftInfoKey = LiftInfoKey.Entry[_]

  object LiftInfo {
    def apply(dir: File, obj: String, pkg: String, keys: Seq[LiftInfoKey],
        proj: ProjectRef, state: State, cacheDir: File): File =
      LiftInfoTask(dir, obj, pkg, keys, proj, state, cacheDir).file

    private case class LiftInfoTask(dir: File, obj: String, pkg: String, keys: Seq[LiftInfoKey],
        proj: ProjectRef, state: State, cacheDir: File) {
      import FileInfo.hash
      import Tracked.inputChanged

      def extracted = Project.extract(state)
      val tempFile = cacheDir / "sbtliftinfo" / s"""$obj.scala"""
      val outFile = dir / (s"""$obj.properties""")

      // 1. make the file under cache/sbtliftinfo.
      // 2. compare its SHA1 against cache/sbtliftinfo-inputs
      def file: File = {
        makeFile(tempFile)
        cachedCopyFile { hash(tempFile) }
        outFile
      }

      val cachedCopyFile =
        inputChanged(cacheDir / "sbtliftinfo-inputs") { (inChanged, input: HashFileInfo) =>
          if (inChanged || !outFile.exists) {
            IO.copyFile(tempFile, outFile, true)
          } // if
        }

      def makeFile(file: File): File = {
        val distinctKeys = keys.toList.distinct
        val lines =
          List(s"""# This file was generated by sbt-liftinfo.""") :::
            (distinctKeys flatMap { lineProps(_) })
         // (distinctKeys flatMap { line(_) }) :::
         // List(toStringLine(distinctKeys), "") :::
         // makeToMapMethod(distinctKeys) ::: List("}")
        IO.write(file, lines.mkString("\n"))
        file
      }

      def line(info: LiftInfoKey): List[String] =
        entry(info) match {
          case Some((ident, value)) =>
            val typeDecl: String = getType(info) map { ": " + _ } getOrElse ""
            List(s"""  /** The value is ${quote(value)}. */""",
              s"""  val $ident$typeDecl = ${quote(value)}""")
          case _ => Nil
        }

      def lineProps(info: LiftInfoKey): List[String] =
        entry(info) match {
          case Some((ident, value)) =>
            val typeDecl: String = getType(info) map { ": " + _ } getOrElse ""
            List(
              s"""$ident$typeDecl=${noquote(value)}""")
          case _ => Nil
        }

      def toStringLine(keys: Seq[LiftInfoKey]): String = {
        val idents = keys.map(entry(_)).flatten.map(_._1)
        val fmt = idents.map("%s: %%s" format _).mkString(", ")
        val vars = idents.mkString(", ")
        s"""  override val toString = "$fmt" format ($vars)"""
      }

      def makeToMapMethod(distinctKeys: List[LiftInfoKey]): List[String] =
        distinctKeys.map { key => entry(key) }.flatten.map {
          case (ident, _) => "    \"%s\" -> %s".format(ident, ident)
        }.mkString("  val toMap = Map[String, Any](\n", ",\n", ")").split("\n").toList

      def entry[A](info: LiftInfoKey.Entry[A]): Option[(String, A)] = info match {
        case LiftInfoKey.Setting(key)      => extracted getOpt (key in scope(key)) map { ident(key) -> _ }
        case LiftInfoKey.Task(key)         => Some(ident(key) -> extracted.runTask(key in scope(key), state)._2)
        case LiftInfoKey.Constant(tuple)   => Some(tuple)
        case LiftInfoKey.Action(name, fun) => Some(name -> fun.apply)
        case LiftInfoKey.Mapped(from, fun) => entry(from) map fun
      }

      def scope(scoped: Scoped) = {
        val scope0 = scoped.scope
        if (scope0.project == This) scope0 in (proj)
        else scope0
      }

      def ident(scoped: Scoped) : String = {
        val scope = scoped.scope
        (scope.config.toOption match {
          case None => ""
          case Some(ConfigKey("compile")) => ""
          case Some(ConfigKey(x)) => x + "_"
        }) +
        (scope.task.toOption match {
          case None => ""
          case Some(x) => x.label + "_"
        }) +
        (scoped.key.label.split("-").toList match {
          case Nil => ""
          case x :: xs => x + (xs map {_.capitalize}).mkString("")
        })
      }

      def getType(info: LiftInfoKey): Option[String] = {
        val mf = info.manifest
        if(mf.runtimeClass == classOf[Option[_]]) {
          val s = mf.toString
          Some(if( s.startsWith("scala.")) s.substring(6) else s)
        } else None
      }

      def quote(v: Any): String = v match {
        case x @ ( _: Int | _: Double | _: Boolean | _: Symbol) => x.toString
        case x: Long            => x.toString + "L"
        case node: scala.xml.NodeSeq if node.toString.trim.nonEmpty => node.toString
        case (k, _v)            => "(%s -> %s)" format(quote(k), quote(_v))
        case mp: Map[_, _]      => mp.toList.map(quote(_)).mkString("Map(", ", ", ")")
        case seq: Seq[_]        => seq.map(quote(_)).mkString("Seq(", ", ", ")")
        case op: Option[_]      => op map { x => "Some(" + quote(x) + ")" } getOrElse {"None"}
        case url: java.net.URL  => "new java.net.URL(%s)" format quote(url.toString)
        case file: java.io.File => "new java.io.File(%s)" format quote(file.toString)
        case s                  => "\"%s\"" format encodeStringLiteral(s.toString)
      }

      def noquote(v: Any): String = v match {
        case x @ ( _: Int | _: Double | _: Boolean | _: Symbol) => x.toString
        case x: Long            => x.toString + "L"
        case node: scala.xml.NodeSeq if node.toString.trim.nonEmpty => node.toString
        case (k, _v)            => "(%s -> %s)" format(quote(k), quote(_v))
        case mp: Map[_, _]      => mp.toList.map(quote(_)).mkString("Map(", ", ", ")")
        case seq: Seq[_]        => seq.map(quote(_)).mkString("Seq(", ", ", ")")
        case op: Option[_]      => op map { x => "Some(" + quote(x) + ")" } getOrElse {"None"}
        case url: java.net.URL  => "new java.net.URL(%s)" format quote(url.toString)
        case file: java.io.File => "new java.io.File(%s)" format quote(file.toString)
        case s                  => "%s" format encodeStringLiteral(s.toString)
      }

      def encodeStringLiteral(str: String): String =
        str.replace("\\","\\\\").replace("\n","\\n").replace("\b","\\b").replace("\r","\\r").
          replace("\t","\\t").replace("\'","\\'").replace("\f","\\f").replace("\"","\\\"")
    }
  }

  def buildNumberTask(dir: File, increment: Int): Int = {
    val file: File = dir / "liftinfo.properties"
    val prop = new java.util.Properties

    def readProp: Int = {  
      prop.load(new java.io.FileInputStream(file))
      prop.getProperty("buildnumber", "0").toInt
    }
    def writeProp(value: Int) {
      prop.setProperty("buildnumber", value.toString)
      prop.store(new java.io.FileOutputStream(file), null)
    }
    val current = if (file.exists) readProp
                  else 0
    writeProp(current + increment)
    current
  }

  lazy val liftInfoSettings: Seq[Def.Setting[_]] = Seq(
    liftInfo <<= (liftInfoDirDestination,
        liftInfoObject, liftInfoPackage, liftInfoKeys, thisProjectRef, state, streams) map {
      (dir, obj, pkg, keys, ref, state, taskStreams) =>
      Seq(LiftInfo(dir, obj, pkg, keys, ref, state, taskStreams.cacheDirectory))
    },
    //liftInfoObject  := "lift-info",
    liftInfoPackage := "liftinfo",
        liftInfoDirDestination  := {
          sourceDirectory.value  / "main" / "resources"
        }  ,
    liftInfoKeys    := Seq(name, version, scalaVersion, sbtVersion),
    liftInfoBuildNumber <<= (baseDirectory) map { (dir) => buildNumberTask(dir, 1) }
  )
}
